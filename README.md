# B5-Assignment-2-DBMS-PostgreSQL
# Primary Key এবং Foreign Key:`BLog1`
প্রাইমারি কি (Primary Key) হচ্ছে একটি টেবিলের মেইন কি। আর রেফারেন্স কি (Reference Key) হচ্ছে অন্য একটি টেবিলের মেইন কি, যখন সেটি রেফারেন্স হিসেবে কাজ করে।

এখন, ডেটাবেজের প্রত্যেকটি টেবিলেই একটি **ইউনিক কি** থাকে, যেটি দিয়ে সহজে রো বা রেকর্ডকে আইডেন্টিফাই করা যায়। এটাকেই মূলত **প্রাইমারি কি (Primary Key)** বলা হয়।

## তাহলে ফরেন কি (Foreign Key) কখন ব্যবহার করা হয়?

আসলে, যখন রেফারেন্স হিসেবে কাজ করার প্রয়োজন হয়—অর্থাৎ, যখন আমরা বিভিন্ন **joining** এর কাজগুলো করি—তখন এই ফরেন কি দরকার হয়।  
এটাকে ধরতে গেলে একটি **লেজের মতো** বলা যায়, যেটি অন্য টেবিলের মেইন কি (**Primary Key**) কে রেফার করে।

ধরো, দুইটি টেবিল আছে। এই দুইটি টেবিলের মধ্যে কানেকশন কিভাবে ঘটাবে? কেউ তো কাউকে চিনে না! এখানেই **Foreign Key** এগুলো কাজে লাগে। ফরেন কি অন্য টেবিলের **Primary Key** কে রেফার করে।

এতে সহজেই আমরা বিভিন্ন **joining** ব্যবহার করতে পারি। এছাড়া, **delete** বা **update** এর ক্ষেত্রেও **Foreign Key** খুব কাজে লাগে।  
বিশেষ করে, **ON DELETE CASCADE** বা **ON DELETE RESTRICT** জাতীয় কাজে **Foreign Key** অপরিহার্য।

- **Primary Key** কখনো খালি (**NULL**) থাকতে পারবে না, কিন্তু **Foreign Key** খালি থাকতে পারবে।
- একটি টেবিলে **একটিমাত্র প্রাইমারি কি** কলাম থাকতে পারে।
- কিন্তু একটি টেবিলে **একাধিক Foreign Key** কলাম থাকতে পারে।
- **Primary Key** অবশ্যই **Unique** হবে, না হলে **error** চলে আসবে।
- কিন্তু **Foreign Key** **ইউনিক না হলেও** চলবে।

## কেন Foreign Key ইউনিক না হলেও চলে?

**কারণ:**  
- ধরো একটি **Orders** টেবিলে অনেকগুলো **user_id** আছে।
- একজন ইউজার অনেকগুলো অর্ডার করতে পারে, তাই একই **user_id** বারবার আসতে পারে।
- যদি **Foreign Key** ইউনিক থাকতো, তাহলে একই ইউজার একাধিক অর্ডার দিতে পারত না।

**সুতরাং, Foreign Key ইউনিক না হলেও চলে।**

## Foreign Key কেন NULL হতে পারে?

**কারণ:**  
- **Foreign Key** আসলে রেফারেন্সের জন্য, কিন্তু সব সময় রেফারেন্স থাকা বাধ্যতামূলক নয়।
- উদাহরণস্বরূপ, এমন অর্ডার আসতে পারে যেটি **Guest Order**, অর্থাৎ, কোনো ইউজারের সাথে যুক্ত নয়।
- এই ক্ষেত্রে **Foreign Key** (যেমন `user_id`) কলাম **NULL** হলেও কোনো সমস্যা নেই।


# VARCHAR এবং CHARACTER ডাটা টাইপের মধ্যে পার্থক্য

**VARCHAR** এবং **CHARACTER (CHAR)** ডাটা টাইপের মধ্যে পার্থক্যটা এখানেই যে **CHARACTER (CHAR)** ফিক্সড ডাটা ব্যবহার করে, আর **VARCHAR** ফিক্সড ব্যবহার করে না।

- **VARCHAR** যতটুকু প্রয়োজন ঠিক ততটুকুই জায়গা দখল করে, এর বেশিও না এবং কমও না।  
- অন্যদিকে, **CHARACTER (CHAR)** যেহেতু ফিক্সড লেংথের, যদি কম ডাটা ইনসার্ট করা হয়, তবুও অতিরিক্ত স্পেস নিয়ে বসে থাকে।

যদি এমন হয় যে, ডাটা সবসময় একই আকারের (fixed length) দিতে হবে, তখন আমরা **CHARACTER** ব্যবহার করতে পারি। এতে সবসময় একইরকম ডাটা থাকবে।

তবে **মেমোরি এফিসিয়েন্সি** এবং **ফ্লেক্সিবিলিটির** জন্য বেশিরভাগ মানুষই **VARCHAR** ব্যবহার করে।



# SELECT আর WHERE কাকে বলে?

ডাটাবেজে **SELECT** মূলত ডাটা নিয়ে আসার কাজ করে।  
যেমন ধরো, তুমি একটা টেবিল থেকে ডাটা চাইলে SELECT দিয়ে সেটা পাওয়া যায়। তুমি চাইলে টেবিলের সব ডাটা বা শুধু কিছু নির্দিষ্ট কলামও নিতে পারো।

আর **WHERE** হচ্ছে ডাটাকে ফিল্টার করার জন্য।  
মানে, তোমাকে পুরো টেবিলের ডাটা দরকার হয় না, শুধু বিশেষ কিছু শর্ত পূরণ করে এমন ডাটা দরকার—সেটাই WHERE দিয়ে নেওয়া হয়। 

## WHERE কিভাবে কাজ করে?

WHERE এর ভিতর তুমি বিভিন্ন শর্ত দিতে পারো, যেমন:  
- বড় বা ছোট (>, <)  
- সমান (=)  
- টেক্সট মিলে কি না (LIKE)  
- একাধিক শর্ত (AND, OR)  
- নির্দিষ্ট রেঞ্জের মধ্যে (BETWEEN)  
- অথবা নেস্টেড কন্ডিশন (সাবকোয়েরি)

## Example:

তুমি যদি ইউজারদের মধ্যে শুধু ২৫ বছরের বেশি বয়সের লোকদের দেখতে চাও, তাহলে WHERE এর সাহায্যে সেটা ফিল্টার করবে।

## আরেকটু Explaination:

- যদি দেশের নাম দিয়ে ডাটা দরকার, তাহলে WHERE দিয়ে ফিল্টার করবে।  
- নামের শুরু বা শেষের অক্ষর দিয়ে ডাটা নিতে LIKE ব্যবহার করতে পারো।  
- টাইম বা সংখ্যা রেঞ্জ দিতে BETWEEN ব্যবহার করো।  
- দরকার হলে সাবকোয়েরি দিয়েও জটিল ফিল্টার করতে পারো।

## Finally:

- **SELECT** = ডাটা আনা  
- **WHERE** = ডাটা ফিল্টার করা

WHERE ব্যবহার করলে ডাটার মধ্যে দরকারি অংশই আসে, ফলে কাজ দ্রুত হয় আর কম ঝামেলা।
