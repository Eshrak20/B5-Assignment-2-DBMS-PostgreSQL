# B5-Assignment-2-DBMS-PostgreSQL
# Primary Key এবং Foreign Key: `Blog1`
প্রাইমারি কি (Primary Key) হচ্ছে একটি টেবিলের মেইন কি। আর রেফারেন্স কি (Reference Key) হচ্ছে অন্য একটি টেবিলের মেইন কি, যখন সেটি রেফারেন্স হিসেবে কাজ করে।

এখন, ডেটাবেজের প্রত্যেকটি টেবিলেই একটি **ইউনিক কি** থাকে, যেটি দিয়ে সহজে রো বা রেকর্ডকে আইডেন্টিফাই করা যায়। এটাকেই মূলত **প্রাইমারি কি (Primary Key)** বলা হয়।

## তাহলে ফরেন কি (Foreign Key) কখন ব্যবহার করা হয়?

আসলে, যখন রেফারেন্স হিসেবে কাজ করার প্রয়োজন হয়—অর্থাৎ, যখন আমরা বিভিন্ন **joining** এর কাজগুলো করি—তখন এই ফরেন কি দরকার হয়।  
এটাকে ধরতে গেলে একটি **লেজের মতো** বলা যায়, যেটি অন্য টেবিলের মেইন কি (**Primary Key**) কে রেফার করে।

ধরো, দুইটি টেবিল আছে। এই দুইটি টেবিলের মধ্যে কানেকশন কিভাবে ঘটাবে? কেউ তো কাউকে চিনে না! এখানেই **Foreign Key** এগুলো কাজে লাগে। ফরেন কি অন্য টেবিলের **Primary Key** কে রেফার করে।

এতে সহজেই আমরা বিভিন্ন **joining** ব্যবহার করতে পারি। এছাড়া, **delete** বা **update** এর ক্ষেত্রেও **Foreign Key** খুব কাজে লাগে।  
বিশেষ করে, **ON DELETE CASCADE** বা **ON DELETE RESTRICT** জাতীয় কাজে **Foreign Key** অপরিহার্য।

- **Primary Key** কখনো খালি (**NULL**) থাকতে পারবে না, কিন্তু **Foreign Key** খালি থাকতে পারবে।
- একটি টেবিলে **একটিমাত্র প্রাইমারি কি** কলাম থাকতে পারে।
- কিন্তু একটি টেবিলে **একাধিক Foreign Key** কলাম থাকতে পারে।
- **Primary Key** অবশ্যই **Unique** হবে, না হলে **error** চলে আসবে।
- কিন্তু **Foreign Key** **ইউনিক না হলেও** চলবে।

## কেন Foreign Key ইউনিক না হলেও চলে?

**কারণ:**  
- ধরো একটি **Orders** টেবিলে অনেকগুলো **user_id** আছে।
- একজন ইউজার অনেকগুলো অর্ডার করতে পারে, তাই একই **user_id** বারবার আসতে পারে।
- যদি **Foreign Key** ইউনিক থাকতো, তাহলে একই ইউজার একাধিক অর্ডার দিতে পারত না।

**সুতরাং, Foreign Key ইউনিক না হলেও চলে।**

## Foreign Key কেন NULL হতে পারে?

**কারণ:**  
- **Foreign Key** আসলে রেফারেন্সের জন্য, কিন্তু সব সময় রেফারেন্স থাকা বাধ্যতামূলক নয়।
- উদাহরণস্বরূপ, এমন অর্ডার আসতে পারে যেটি **Guest Order**, অর্থাৎ, কোনো ইউজারের সাথে যুক্ত নয়।
- এই ক্ষেত্রে **Foreign Key** (যেমন `user_id`) কলাম **NULL** হলেও কোনো সমস্যা নেই।


# VARCHAR এবং CHARACTER ডাটা টাইপের মধ্যে পার্থক্য `Blog2`

**VARCHAR** এবং **CHARACTER (CHAR)** ডাটা টাইপের মধ্যে পার্থক্যটা এখানেই যে **CHARACTER (CHAR)** ফিক্সড ডাটা ব্যবহার করে, আর **VARCHAR** ফিক্সড ব্যবহার করে না।

- **VARCHAR** যতটুকু প্রয়োজন ঠিক ততটুকুই জায়গা দখল করে, এর বেশিও না এবং কমও না।  
- অন্যদিকে, **CHARACTER (CHAR)** যেহেতু ফিক্সড লেংথের, যদি কম ডাটা ইনসার্ট করা হয়, তবুও অতিরিক্ত স্পেস নিয়ে বসে থাকে।

যদি এমন হয় যে, ডাটা সবসময় একই আকারের (fixed length) দিতে হবে, তখন আমরা **CHARACTER** ব্যবহার করতে পারি। এতে সবসময় একইরকম ডাটা থাকবে।

তবে **মেমোরি এফিসিয়েন্সি** এবং **ফ্লেক্সিবিলিটির** জন্য বেশিরভাগ মানুষই **VARCHAR** ব্যবহার করে।



# SELECT আর WHERE কাকে বলে? `Blog3`

ডাটাবেজে **SELECT** মূলত ডাটা নিয়ে আসার কাজ করে।  
যেমন ধরো, তুমি একটা টেবিল থেকে ডাটা চাইলে SELECT দিয়ে সেটা পাওয়া যায়। তুমি চাইলে টেবিলের সব ডাটা বা শুধু কিছু নির্দিষ্ট কলামও নিতে পারো।

আর **WHERE** হচ্ছে ডাটাকে ফিল্টার করার জন্য।  
মানে, তোমাকে পুরো টেবিলের ডাটা দরকার হয় না, শুধু বিশেষ কিছু শর্ত পূরণ করে এমন ডাটা দরকার—সেটাই WHERE দিয়ে নেওয়া হয়। 

## WHERE কিভাবে কাজ করে?

WHERE এর ভিতর তুমি বিভিন্ন শর্ত দিতে পারো, যেমন:  
- বড় বা ছোট (>, <)  
- সমান (=)  
- টেক্সট মিলে কি না (LIKE)  
- একাধিক শর্ত (AND, OR)  
- নির্দিষ্ট রেঞ্জের মধ্যে (BETWEEN)  
- অথবা নেস্টেড কন্ডিশন (সাবকোয়েরি)

## Example:

তুমি যদি ইউজারদের মধ্যে শুধু ২৫ বছরের বেশি বয়সের লোকদের দেখতে চাও, তাহলে WHERE এর সাহায্যে সেটা ফিল্টার করবে।

## আরেকটু Explaination:

- যদি দেশের নাম দিয়ে ডাটা দরকার, তাহলে WHERE দিয়ে ফিল্টার করবে।  
- নামের শুরু বা শেষের অক্ষর দিয়ে ডাটা নিতে LIKE ব্যবহার করতে পারো।  
- টাইম বা সংখ্যা রেঞ্জ দিতে BETWEEN ব্যবহার করো।  
- দরকার হলে সাবকোয়েরি দিয়েও জটিল ফিল্টার করতে পারো।

## Finally:

- **SELECT** = ডাটা আনা  
- **WHERE** = ডাটা ফিল্টার করা

WHERE ব্যবহার করলে ডাটার মধ্যে দরকারি অংশই আসে, ফলে কাজ দ্রুত হয় আর কম ঝামেলা।




# ডাটা আপডেট করার নিয়ম `Blog4`

ডাটা আপডেট করতে চাইলে **UPDATE** কীওয়ার্ড ব্যবহার করতে হয় এবং **SET** ব্যবহার করতে হয়।  
**SET** দিয়ে প্রথমে ওই টেবিলের কলামের নাম দিতে হয়, এরপর সেটি কী চেঞ্জ করতে চাও সেটা দিতে হয়।  

তবে এখানে একটা কিন্তু আছে, সেটা হলো আমাদের অবশ্যই **WHERE** ব্যবহার করতে হবে।  
না হলে পুরো টেবিলের সব ডাটা আপডেট হয়ে যাবে।  

অর্থাৎ, টেবিলের নির্দিষ্ট কলামের নির্দিষ্ট ডাটা আপডেট করার জন্য **WHERE** দিয়ে ফিল্টার করতে হয়।  

---

## Finally

- **UPDATE** দিয়ে টেবিলের ডাটা পরিবর্তন করা হয়।  
- **SET** দিয়ে কলামের নাম ও নতুন মান সেট করা হয়।  
- **WHERE** দিয়ে নির্দিষ্ট রেকর্ডগুলো বাছাই করা হয়।  
- **WHERE** না দিলে টেবিলের সব রেকর্ড আপডেট হয়ে যাবে, যা সাধারণত ভুল।  

এভাবে সাবধানে **UPDATE** ব্যবহার করতে হবে, যাতে ডাটা ঠিকঠাক পরিবর্তন হয়।  







# LIMIT এবং OFFSET কী?

**LIMIT** এবং **OFFSET** মূলত ডাটাবেজ থেকে ডাটা নিয়ে আসার সময় ব্যবহৃত হয়, বিশেষ করে **pagination** এর ক্ষেত্রে।  

## LIMIT কী?

**LIMIT** দিয়ে নির্দিষ্ট সংখ্যক রেকর্ড নিয়ে আসা হয়।  
যেমন ধরো, তুমি хочো একবারে মাত্র ১০ টা রেকর্ড দেখতে, তাহলে LIMIT 10 ব্যবহার করবে।  

## OFFSET কী?

**OFFSET** দিয়ে ডাটার শুরু পজিশন নির্ধারণ করা হয়।  
যেমন ধরো, তুমি ১১তম রেকর্ড থেকে ডাটা দেখতে চাও, তাহলে OFFSET 10 ব্যবহার করবে (কারণ 0 থেকে শুরু)।

## Pagination কিভাবে কাজ করে?

Pagination মানে হলো একাধিক পেইজে ডাটা ভাগ করা।  
প্রথম পেইজে প্রথম ১০ টা ডাটা দেখাবে, দ্বিতীয় পেইজে পরের ১০ টা, তারপর পরের ১০ টা, এরকম।  

এর জন্য আমরা ব্যবহার করব:  
- প্রথম পেইজে: `LIMIT 10 OFFSET 0` (অর্থাৎ প্রথম ১০ টা)  
- দ্বিতীয় পেইজে: `LIMIT 10 OFFSET 10` (১১ থেকে ২০ পর্যন্ত)  
- তৃতীয় পেইজে: `LIMIT 10 OFFSET 20` (২১ থেকে ৩০ পর্যন্ত)  

## কেন LIMIT এবং OFFSET দরকার?

- ডাটাবেজে অনেক রেকর্ড থাকতে পারে, সব একসাথে নিয়ে আসা সময় ও রিসোর্স খরচ বেশি করে।  
- ব্যবহারকারী একসাথে সব ডাটা দেখতে চায় না, বরং ধাপে ধাপে দেখতে চায়।  
- তাই ডাটা ছোট ছোট ভাগে নিয়ে আসা হয়, যেটা পেইজিং নামে পরিচিত।  

---

## Finnally

- **LIMIT** দিয়ে কতগুলো ডাটা নিয়ে আসবে তা নির্ধারণ করা হয়।  
- **OFFSET** দিয়ে ডাটার শুরু পজিশন নির্ধারণ করা হয়।  
- Pagination এর মাধ্যমে ইউজার সহজেই ডাটা ধাপে ধাপে দেখতে পারে।  
- এটা সার্ভার ও ক্লায়েন্ট উভয়ের জন্যই কার্যকর এবং দ্রুত কাজ করে।  
